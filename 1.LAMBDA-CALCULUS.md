# Лямбда-исчисление (Часть I)
----

## Содержание

- Обзор
- Простой пример
- Синтаксис лямбда-исчислений
  - Тест для самопроверки #1
  - Тест для самопроверки #2
- Проблемы с простым правилом переписывания
- Бета-редукция
- Нормальная форма
  - Нормальный и аппликативный порядок редукции
    - Тест для самопроверки #3
    - Тест для самопроверки #4
- Теорема Чёрча-Россера
  - Доказательство следствия 1
  - Доказательство следствия 2
  - Доказательство теоремы Чёрча-Россера
    - 3 задания
    - Задание 1
    - Задание 2
    - Задание 3
      - Тест для самопроверки #5
    - Окончательное доказательство

## Обзор

Лямбда-исчисление - это модель вычислений, открытая Чёрчем в начале 1930-х. Лямбда-исчисление и машина Тьюринга
эквивалентны в том плане, что функция, определенная с помощью одной из этих систем, может быть выражена с помощью
другой.

Вот некоторые пункты сравнения:

| Лямбда-исчисление | Машина Тьюринга |
| ------------------ | -------------- |
| Создает основу для функциональных ЯП (LISP, Scheme, ML). | Создает основу для императивных ЯП (Pascal, ADA, C). |
| Мы пишем лямбда-выражение для каждой функции. Ввод и вывод также лямбда-выражение. | Создается новая машина для вычисления каждой функции. Ввод и вывод записан на ленту |

## Простой пример

Вот простой пример лямбда-выражения, которое определяет функцию *"увеличить на единицу"*:

> &lambda;x.x+1

(Заметим, что это выражение **не** служит примером чистых лямбда-выражений, потому что использует оператор *+*, который
не является частью чистых лямбда-выражений; тем не менее, этот пример проще понять, чем пример с чистыми 
лямбда-выражениями.)

В этом примере определяется функция одного аргумента, который обозначен *'x'*. Телом функции является *"x+1"*. Заметим,
что функция не имеет имени (иначе говоря, это анонимная функция). Что бы вычислить эту функцию необходимо передать ей 
аргумент, например:

> (&lambda;x.x+1)3 

В этом примере *&lambda;x.x+1* является функцией, а 3 её аргументом; а всё в целом представляет собой лямбда-выражение.

Вычисление подразумевает перезаписывание:

> (&lambda;x.x+1)3 &rArr; 3+1 &rArr; 4 

Пока что под перезаписью можете понимать замену внутри функции всех вхождений параметра *'x'* на аргумент (а затем, для
не чистых лямбда-выражений, которые включают операторы наподобие сложения, применение этих операторов). Более точное 
определение будет приведено далее.

## Синтаксис лямбда-исчислений

Синтаксис (чистых) лямбда-исчислений может быть определен следующим образом:

1. Переменные являются лямбда-выражениями (обозначаются одной буквой в нижнем регистре).
2. Если M и N являются лямбда-выражениями, то возможны записи вида:
  1. (M)
  2. &lambda;*id*.M
  3. MN
  
Вот и все!

Правило 2.1 гласит, что мы можем добавлять скобки к выражениям. Правило 2.2 дает определение **абстракции**: функция с
формальным параметром *id* и телом M. Правило 2.3 задаёт **аппликацию**: применение или вызов одного 
лямбда-выражения к другому (M применяется к N).

Заметим, что чистые лямбда-исчисление исключают константы, типы и примитивные операторы (+, \*, ...). Также заметим, что
по соглашению аппликация является лево ассоциативной: ABC означает (AB)C а не A(BC). Аппликация имеет приоритет выше, 
чем абстракция: &lambda;x.AB означает &lambda;x.(AB) а не (&lambda;x.A)B

Правила выше определяют язык лямбда-выражений, который можно выразить используя контекстно-свободную грамматику:

<TABLE>
<tr><td><em>exp</em>
    <td>&rarr;
    <td>ID
<tr><td>
    <td> |
    <td> ( <em>exp</em> )
<tr><td>
    <td> |
    <td> &lambda; ID . <em>exp</em>
    <td> // абстракция
<tr><td>
    <td> | 
    <td> <em>exp exp</em>
    <td> // аппликация
</TABLE>

Как уже говорилось выше, при вычислении лямбда-выражений используется перезаписывание; для каждой аппликации в теле 
функции заменяются все вхождения формального параметра (переменной) на значение фактического параметра 
(лямбда-выражение).

Будет проще понять, если для лямбда-выражений вместо текста мы будем использовать дерево с абстрактным синтаксисом. Вот
простой пример, приведенный выше:

> (&lambda;x.x+1)3

И дерево с абстрактным синтаксисом (где &lambda; это абстракция, а apply - аппликация):

<pre>
        apply
        /   \
       &lambda;     3
      / \
     x   +
        / \
       x   1
</pre>

Для перезаписи дерева с абстрактным синтаксисом мы ищем аппликации функции к аргументам и для каждой из них заменяем
формальный параметр аргументом в теле функции. Чтобы это сделать мы должны найти узел apply у которого левая часть
является лямбда-узлом, так как только лямбда-узлы представляют функции.

1. Правое поддерево узла apply является аргументом.
2. Левое поддерево узла apply (с лямбда-выражением в корневом узле) является функцией.
3. Левый лист лямбда-выражения - это формальный параметр.
4. Правый лист лямбда-выражения - это тело функции.

В нашем примере только один узел apply; аргумент 3, функция &lambda;x.x+1; формальный параметр *x*, тело функции *x+1*.
Приведем переписывание:

<pre>
        apply      =>      +
        /   \             / \
       &lambda;     3           3   1
      / \
     x   +
        / \
       x   1
</pre>

А вот пример с двумя аппликациями:

> (&lambda;x.x+1)((&lambda;y.y+2)3)

Первое лямбда-выражение определяет функцию "увеличить на единицу". Аргументом этой функции является аппликация, которая
применяет функцию "увеличить на 2" к значению 3. Построим дерево с абстрактным синтаксисом и один из способов перезаписи
(отдавая приоритет самой правой аппликации):

<pre>
        apply         =>   apply     =>  apply   =>  +  =>  6
       /     \             /   \         /   \      / \
      &lambda;       apply       &lambda;     +       &lambda;     5    5   1
     / \       /  \      / \   / \     / \
    x   +     &lambda;    3    x   + 3   2   x   +
       / \   / \           / \           / \
      x   1 y   +         x   1         x   1
               / \
              y   2
</pre>

В целом, различные стратегии порядка выбора аппликаций для перезаписи приводят к различным последствиям. Проблема будет 
пояснена далее.

----

## Тест для самопроверки #1

Сделайте переписывание ещё раз, при этом выберите другую аппликацию первой.

[Ответ](#Ответ-1)

----

Заметим, что результат переписывания не чистого лямбда-выражения может являться константой (как в примере выше), но 
результат может быть также лямбда-выражением: переменной, абстракцией или аппликацией.
Для **чистых** лямбда-выражений результат переписывания всегда будет лямбда-выражением.

1. (&lambda;f.&lambda;x.fx)&lambda;y.y+1

    Первое лямбда-выражение определяет функцию, аргумент *f* которой также является функцией, а тело *&lambda;x.fx*
    является другой функцией (которая принимает аргумент *x* и вызывает с ним *f*). Ниже приведены дерево с абстрактным
    синтаксисом и переписывание; возможно вы захотите попробовать нарисовать их сами.
    
    <pre>
        apply      =>   &lambda;        =>    &lambda;        &lambda;x.x+1
       /     \         / \            / \
      &lambda;       &lambda;       x  apply       x   +    
     / \     / \         /   \          / \
    f   &lambda;   y   +       &lambda;     x        x   1
       / \     / \     / \
      x  apply y  1   y   +
         /  \            / \
        f    x          y   1
    </pre>
    
    Обратите внимание, что результатом переписывания является функция. Также заметим, хотя в этом примере и используются
    2 узла "apply", только один из них имеет лямбда-узел, поэтому переписывание может быть начато только одним способом.

2. (&lambda;x.&lambda;y.x)(&lambda;z.z)

    В этом примере первая лямбда принимает один аргумент *x*, и возвращает функцию, которая игнорирует свой собственный 
    аргумент (*y*), просто возвращая *x*. В данном случае значение передаваемое как *x* является функцией.

    <pre>
               apply            &lambda;         &lambda;y.&lambda;z.z
              /     \          / \
             &lambda;       &lambda;    =>  y   &lambda;
            / \     / \          / \
           x   &lambda;   z   z        z   z
              / \
             y   x
    </pre>

----

## Тест для самопроверки #2

Нарисуйте дерево с абстрактным синтаксисом и выполните переписывание для лямбда-выражения:

> (&lambda;x.&lambda;y.xy)(&lambda;z.z)

[Ответ](#Ответ-2)

----

## Проблемы с простым правилом переписывания

Вспомним, что неточное определение переписывания аппликации *(&lambda;x.M)N* означает "*M* с заменой на *N* всех 
вхождений *x*. Однако, с этим определением две проблемы:

**Проблема #1**: В действительности, мы не хотим заменять **все** вхождения *x*. Что бы понять почему, посмотрим на
следующее не чистое лямбда-выражение:

> (&lambda;x.(x + ((&lambda;x.x+1)3)))2

Выражение можно сократить до 6; внутреннее выражение:

> (&lambda;x.x+1)3

принимает один аргумент 3, прибавляет 1, итого 4. Внешнее выражение

> (&lambda;x.(x + 4))2

принимает один один аргумент, значение 2, прибавляет 4, итого 6.

Однако, если мы в первую очередь произведём замену во **внешней** аппликации используя простое правило переписывния, то
получим следующий результат:

<pre>
      apply
       /\
      &lambda;  2
     / \
    x   +                     +
       / \                   / \
      x  apply     =>       2  apply     =>  +    => 5
          / \    (неверная      / \         / \
         &lambda;   3   аппликация)   &lambda;   3       2   +
        / \                   / \             / \
       x   +                 x   +           2   1
          / \                   / \
         x   1                 2   1
</pre>

Получен неверный результат (5 вместо 6), потому что мы заменили все вхождения *x* во внутреннем выражении значением,
переданным как параметр для внешнего выражения.

**Проблема #2**: Рассмотрим чистое лямбда-выражение

> ((&lambda;x.&lambda;y.x)y)z

Это выражение похоже на предыдущее, но в этот раз при применяем *&lambda;x.&lambda;y.x* к двум аргументам (*y* и *z*)
вместо одного аргумента (*&lambda;z.z*). При вызове с двумя аргументами выражение *&lambda;x.&lambda;y.x* должно вернуть
свой первый аргумент, в данном случае результатом переписывания должен быть *y*. Однако, если мы будем использовать 
простое правило переписывания и заменим все вхождения формального параметра *x* на *y*, то получим:

> (&lambda;y.y)z

и после переписывания этого выражения получаем

> z

т.е. был получен второй аргумент вместо первого\! Данный пример иллюстрирует проблему конфликта имен.

Что бы понять как исправть эту проблему необходимо разобраться с **областью видимости**, включающую в себя следующие 
понятия:

- **Связанная переменная**: переменная, которая связана с некоторой лямбдой.
- **Свободная переменная**: переменная, которая *не* связана ни с одной лямбдой.

Интуитивно понятно, что в лямбда-выражении *M* переменная *x* является связанной, если в дереве с абстрактным 
синтаксисом *x* встречается в поддереве лямбды, у которой левой ветвью является *x*:
<pre>

                &lambda;
               / \
              x  /\
                /  \
               /    \
              /..x...\
                 |
                 здесь x связан
</pre>

Приведем точное определение свободных и связанных переменных:

- В выражении *"x"* переменная *x* свободная (нет связанных переменных).
- В выражении *"&lambda;x.M"* каждый *x* в *M* связанный, каждая свободная в *M* является свободной и в *&lambda;x.M*;
  любая связанная в *M* переменная также является связанной в *&lambda;x.M*.
- В выражении *MN*
  - Свободные в *MN* переменные являются объединением двух множеств: свободных в *M* и свободных в *N* переменных.
  - Связанные в *MN* переменные также являются объединением двух множеств: связанных в *M* и связанных в *N* переменных.

Заметим, что переменная может встречаться несколько раз в одном лямбда-выражении; некоторые её вхождения могут быть 
свободными, а некоторые связанными. Таким образом, переменная является *одновременно* и свободной и связанной, но
каждое *вхождение* либо связанной, либо свободной (но не вместе). Например, в следующем лямбда-выражении свободными
переменными являются {y,x}, а связанными {y}:

<pre>
            (&lambda;x.y)(&lambda;y.yx)
                |     ||
                |     |свободная
            свободная |
                    связанная
</pre>

Для того, что бы решить проблему #1 в данном лямбда-выражении

> (&lambda;x.M)N

вместо замены **всех** вхождений *x* в *M* и *N* мы заменим все **свободные** вхождения в *M* с *N*. Пример:

<pre>
                       +----- M ---------+
                       |                 |
                   (&lambda;x. x + ((&lambda;x.x + 1)3)) 2
                        |        |
                        |        |
                   свободный   связанный
                      в M        в M

                     => 2 + ((&lambda;x.x + 1)3)
</pre>

С проблемой #2 дело в том, что переменная *y*, которая была свободным аргументом в исходном лямбда-выражении, становится
связанной после переписывания (использования аргумента для замены всех вхождений формального параметра), потому, что она
попадает в контекст лямбды, у которой, так уж случилось, аргумент тоже назван *y*:

<pre>
    ((&lambda;x.&lambda;y.x)y)z
              |
              |
       свободная, но станет связанной после аппликации
</pre>

Для решения проблемы #2 мы воспользуемся преобразованием под названием **альфа-редукция**. Идея в том, что названия 
формальных параметров не важны; поэтому переименуем их таким образом, что бы избежать конфликта. Альфа-редукция 
используется для преобразования выражений вида *&lambda;x.M*. Оно переименовывает все вхождения *x*, которые являются 
свободными в *M* в некоторую другую переменную *z*, которая не встречается в *M* (т.е. *&lambda;x* становится 
*&lambda;z*). Переменная *z* отсутствует в *M*, поэтому мы можем переименовать *x* в *z*; т.е.

> &lambda;x.&lambda;y.x+y *альфа-редукция* => &lambda;z.&lambda;y.z+y

Приведем псевдокод для альфа-редукции.

<pre>
alphaReduce(M: lambda-expression,
            x: id,
            z: id) {

  // предварительное условие: z не встречается в M
  // постусловие: вернуть M с заменой всех свободных вхождений x на z

  case M of {

    VAR(x): return VAR(z)

    VAR(y): return VAR(y)

    APPLY(e1, e2): return APPLY(alphaReduce(e1, x, z), alphaReduce(e2, x, z))

    LAMBDA(x,e): return LAMBDA(x,e)

    LAMBDA(y,e): return LAMBDA(y, alphaReduce(e, x, z))
  }
}
</pre>

Замечание: другой способ для решения проблемы #2 это использование так называемой нотации **де Брауна**, которая 
использует целые числа вместо обозначений. Её изучение будет домашним заданием.

## Бета-редукция

Наконец-то мы готовы дать точное определение переписыванию:

- оно называется бета-редукцией или бета-упрощением;
- оно определяется при помощи подстановки (которая в свою очередь использует альфа-редукцию).

Для бета-редукции используется следующая нотация:

> (&lambda;x.M)N &rarr;<sub>&beta;</sub> M[N/x]

Левая часть *((&lambda;x.M)N)* называется **редекс** (redex), а правая *(M[N/x])* называется **контрактус** 
(contractum). Нотация обозначает *M* с заменеными свободными вхождениями *x* на *N* без конфликта имен. Мы говорим, что 
*(&lambda;x.M)N* упрощается до *M* с подстановкой *N* в *x*. Далее приведен псевдокод для замены.

<pre>
substitute(M: lambda-expression,
           x: id,
           N: lambda-expression) {

  // когда замена вызвана в первый раз M является телом функции в виде &lambda;x.M

  case M of {
    VAR(x): return N

    VAR(y): return M

    LAMBDA(x,e): return M // в том случае, если отсутствуют свободные вхождения
                          // x в M, т.е. нечего заменять;
                          // заметим, что это решает проблему #1

    LAMBDA(y,e):
       if (y не является свободной в N)
       then return LAMBDA(y,substitute(e,x,N)) // замена x на N в теле
                                               // лямбда-выражения
       else { // y имеет свободные вхождения в N; здесь решается проблема #2
          let y' идентификатор, не являющийся не x и не y, и 
                 не входящий не в N, не в e;
          let e' = alphaReduce(e,y,y');
          return LAMBDA(y',substitute(e',x,N))
       }

    APPLY(e1,e2): return APPLY(substitute(e1,x,N), substitute(e2,x,N))
  }
}
</pre>

Что бы проиллюстрировать работу бета-редукции, рассмотрим предыдущий пример проблемы #2. Далее приведены шаги 
бета-редукции:

<pre>
        ((&lambda;x.&lambda;y.x)y)z
                ->  ((&lambda;y.x)[y/x])z   // заменяем x на y в теле "&lambda;y.x"
                ->  ((&lambda;y'.x)[y/x])z  // после альфа-редукции
                ->  (&lambda;y'.y)z         // первая бета-редукция завершена!
                ->  y[z/y']          // замена y' на z в "y"
                ->  y                // вторая бета-редукция завершена!
</pre>

Обратим внимание, что термин "бета-*упрощение*" не совсем верно, поскольку применение бета-редукции не всегда дает
меньшее лямбда-выражение. По факту, бета-редукция:

- уменьшает
- увеличивает
- не изменяет

длину лямбда-выражения. Далее будут приведены примеры. В первом случае результатом бета-редукции является исходное 
выражение (т.е. длина не изменилась); во-втором примере лямбда-выражение становится длинее; а в-третьем примере 
сначало выражение становится длинее, а затем короче.

- (&lambda;x.xx)(&lambda;x.xx) &rarr; (&lambda;x.xx)(&lambda;x.xx) 
- (&lambda;x.xxx)(&lambda;x.xxx) &rarr; (&lambda;x.xxx)(&lambda;x.xxx)(&lambda;x.xxx) &rarr; (&lambda;x.xxx)(&lambda;x.xxx)(&lambda;x.xxx)(&lambda;x.xxx)
- (&lambda;x.xx)(&lambda;a.&lambda;b.bbb) &rarr; (&lambda;a.&lambda;b.bbb)(&lambda;a.&lambda;b.bbb) &rarr; &lambda;b.bbb

## Нормальная форма

Как мы уже обсуждали ранее, вычисление лямбда-выражений влечет в себе их переписывание применяя бета-редукцию. Помиимо
этого, существует ещё одна операция под названием **бета-расширение**, которую мы так же можем использовать. По 
определению, лямбда-выражение e1 бета-расширяется в e2, если e2 бета-упрощается до e1. Например, выражение

> xy

beta-expands to each of the following:

<pre>
    (&lambda;a.a)xy
    (&lambda;a.xy)(&lambda;z.z)
    (&lambda;a.ay)x
</pre>

Вычисления останавливаются, когда уже больше нет редексов (не осталось аппликаций функций и аргументов). Мы говорим, что
лямбда-выражение без редексов находится в **нормальной форме**. Также, лямбда-выражение **имеет** нормальную форму, если 
существует последовательность бета-редукций и/или бета-расширений, которые приводят к нормальной форме.

Отсюда мы получаем несколько интересных вопросов о нормальной форме:

1. В: Правда, что каждое лямбда-выражение имеет нормальную форму?
  
    О: Нет, например (&lambda;z.zz)(&lambda;z.zz). Заметим, что это и не должно быть удивительным, поскольку так как
    лямбда-выражения эквивалентны Машине Тьюринга, а мы знаем, что Машина Тьюринга может не суметь остановиться 
    (например, программа может попасть в вечный цикл или бесконечную рекурсию).
    
2. В: Если лямбда-выражение имеет нормальную форму, можем ли мы перейти к ней используя только бета-редукцию, или нам
    понадобится использовать бета-расширения?
    
    О: Должно хватить бета-редукций (это одно из следствий теоремы Чёрча-Россера, уже не за горами!)

3. В: Если лямбда-выражение имеет нормальную форму, при любой ли последовательности редукций мы к ней придем?
    
    О: Нет. Рассмотрим следующее лямбда-выражение:
    
    > (&lambda;x.&lambda;y.y)((&lambda;z.zz)(&lambda;z.zz))
    
    Это лямбда-выражение содержет два редекса: первый это всё выражение целиком (аппликация *(&lambda;x.&lambda;y.y)* к
    его аргументу); второе - это аргумент: *((&lambda;z.zz)(&lambda;z.zz))*. Второй редекс как раз является примером
    лямбда-выражения без нормальной формы - каждый раз применяя к нему бета-редукцию мы получаем то же самое выражение.
    Очевидно, что если мы будем выбирать этот редекс для упрощения, то мы никогда не найдём нормальную форму для всего
    выражения. Хотя, если мы упростим первый редекс, мы получим *&lambda;y.y*, что и является нормальной формой.
    Следовательно, последовательность наших упрощений **может** определить, получим мы нормальную форму или нет.

4. В: Существует ли стратегия для выбора бета-редукций, которая точно позволит придти к нормальной форме, если, конечно,
    такая существует?
    
    О: Да! Она называется *редукция нормального порядока*, и ниже мы дадим ей определние.

### Ответ 1

<pre>
        apply         =>    +     =>  +   =>  +  =>  6
       /     \             / \       / \     / \
      &lambda;       apply     apply 1     +   1   5   1
     / \       /  \      / \       / \
    x   +     &lambda;    3    &lambda;   3    3    2
       / \   / \       / \     
      x   1 y   +     y   +    
               / \       / \
	      y   2     y   2
</pre>

### Ответ 2

<pre>
     apply      =>       &lambda;     =>        &lambda;      &lambda;y.y
    /     \             / \             / \
   &lambda;       &lambda;           y   apply       y   y
  / \     / \             /     \
 x   &lambda;   z   z           &lambda;       y
    / \                 / \
   y  apply            z   z
     /     \
    x       y
</pre>
