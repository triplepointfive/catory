# Лямбда-исчисление (Часть I)
----

## Содержание

- Обзор
- Простой пример
- Синтаксис лямбда-исчислений
  - Тест для самопроверки #1
  - Тест для самопроверки #2
- Проблемы с простым правилом переписывания
- Бета-редукция
- Нормальная форма
  - Нормальный и аппликативный порядок редукции
    - Тест для самопроверки #3
    - Тест для самопроверки #4
- Теорема Чёрча-Россера
  - Доказательство следствия 1
  - Доказательство следствия 2
  - Доказательство теоремы Чёрча-Россера
    - 3 задания
    - Задание 1
    - Задание 2
    - Задание 3
      - Тест для самопроверки #5
    - Окончательное доказательство

## Обзор

Лямбда-исчисление - это модель вычислений, открытая Чёрчем в начале 1930-х. Лямбда-исчисление и машина Тьюринга
эквивалентны в том плане, что функция, определенная с помощью одной из этих систем, может быть выражена с помощью
другой.

Вот некоторые пункты сравнения:

| Лямбда-исчисление | Машина Тьюринга |
| ------------------ | -------------- |
| Создает основу для функциональных ЯП (LISP, Scheme, ML). | Создает основу для императивных ЯП (Pascal, ADA, C). |
| Мы пишем лямбда-выражение для каждой функции. Ввод и вывод также лямбда-выражение. | Создается новая машина для вычисления каждой функции. Ввод и вывод записан на ленту |

## Простой пример

Вот простой пример лямбда-выражения, которое определяет функцию *"увеличить на единицу"*:

> &lambda;x.x+1

(Заметим, что это выражение **не** служит примером чистых лямбда-выражений, потому что использует оператор *+*, который
не является частью чистых лямбда-выражений; тем не менее, этот пример проще понять, чем пример с чистыми 
лямбда-выражениями.)

В этом примере определяется функция одного аргумента, который обозначен *'x'*. Телом функции является *"x+1"*. Заметим,
что функция не имеет имени (иначе говоря, это анонимная функция). Что бы вычислить эту функцию необходимо передать ей 
аргумент, например:

> (&lambda;x.x+1)3 

В этом примере *&lambda;x.x+1* является функцией, а 3 её аргументом; а всё в целом представляет собой лямбда-выражение.

Вычисление подразумевает перезаписывание:

> (&lambda;x.x+1)3 &rArr; 3+1 &rArr; 4 

Пока что под перезаписью можете понимать замену внутри функции всех вхождений параметра *'x'* на аргумент (а затем, для
не чистых лямбда-выражений, которые включают операторы наподобие сложения, применение этих операторов). Более точное 
определение будет приведено далее.

## Синтаксис лямбда-исчислений

Синтаксис (чистых) лямбда-исчислений может быть определен следующим образом:

1. Переменные являются лямбда-выражениями (обозначаются одной буквой в нижнем регистре).
2. Если M и N являются лямбда-выражениями, то возможны записи вида:
  1. (M)
  2. &lambda;*id*.M
  3. MN
  
Вот и все!

Правило 2.1 гласит, что мы можем добавлять скобки к выражениям. Правило 2.2 дает определение **абстракции**: функция с
формальным параметром *id* и телом M. Правило 2.3 задаёт **аппликацию**: применение или вызов одного 
лямбда-выражения к другому (M применяется к N).

Заметим, что чистые лямбда-исчисление исключают константы, типы и примитивные операторы (+, \*, ...). Также заметим, что
по соглашению аппликация является лево ассоциативной: ABC означает (AB)C а не A(BC). Аппликация имеет приоритет выше, 
чем абстракция: &lambda;x.AB означает &lambda;x.(AB) а не (&lambda;x.A)B

Правила выше определяют язык лямбда-выражений, который можно выразить используя контекстно-свободную грамматику:

<TABLE>
<tr><td><em>exp</em>
    <td>&rarr;
    <td>ID
<tr><td>
    <td> |
    <td> ( <em>exp</em> )
<tr><td>
    <td> |
    <td> &lambda; ID . <em>exp</em>
    <td> // абстракция
<tr><td>
    <td> | 
    <td> <em>exp exp</em>
    <td> // аппликация
</TABLE>

Как уже говорилось выше, при вычислении лямбда-выражений используется перезаписывание; для каждой аппликации в теле 
функции заменяются все вхождения формального параметра (переменной) на значение фактического параметра 
(лямбда-выражение).

Будет проще понять, если для лямбда-выражений вместо текста мы будем использовать дерево с абстрактным синтаксисом. Вот
простой пример, приведенный выше:

> (&lambda;x.x+1)3

И дерево с абстрактным синтаксисом (где &lambda; это абстракция, а apply - аппликация):

<pre>
        apply
        /   \
       &lambda;     3
      / \
     x   +
        / \
       x   1
</pre>

Для перезаписи дерева с абстрактным синтаксисом мы ищем аппликации функции к аргументам и для каждой из них заменяем
формальный параметр аргументом в теле функции. Чтобы это сделать мы должны найти узел apply у которого левая часть
является лямбда-узлом, так как только лямбда-узлы представляют функции.

1. Правое поддерево узла apply является аргументом.
2. Левое поддерево узла apply (с лямбда-выражением в корневом узле) является функцией.
3. Левый лист лямбда-выражения - это формальный параметр.
4. Правый лист лямбда-выражения - это тело функции.

В нашем примере только один узел apply; аргумент 3, функция &lambda;x.x+1; формальный параметр *x*, тело функции *x+1*.
Приведем переписывание:

<pre>
        apply      =>      +
        /   \             / \
       &lambda;     3           3   1
      / \
     x   +
        / \
       x   1
</pre>

А вот пример с двумя аппликациями:

> (&lambda;x.x+1)((&lambda;y.y+2)3)

Первое лямбда-выражение определяет функцию "увеличить на единицу". Аргументом этой функции является аппликация, которая
применяет функцию "увеличить на 2" к значению 3. Построим дерево с абстрактным синтаксисом и один из способов перезаписи
(отдавая приоритет самой правой аппликации):

<pre>
        apply         =>   apply     =>  apply   =>  +  =>  6
       /     \             /   \         /   \      / \
      &lambda;       apply       &lambda;     +       &lambda;     5    5   1
     / \       /  \      / \   / \     / \
    x   +     &lambda;    3    x   + 3   2   x   +
       / \   / \           / \           / \
      x   1 y   +         x   1         x   1
               / \
              y   2
</pre>

В целом, различные стратегии порядка выбора аппликаций для перезаписи приводят к различным последствиям. Проблема будет 
пояснена далее.

----

## Тест для самопроверки #1

Сделайте переписывание ещё раз, при этом выберите другую аппликацию первой.

[Ответ](#Ответ-1)

----

Заметим, что результат переписывания не чистого лямбда-выражения может являться константой (как в примере выше), но 
результат может быть также лямбда-выражением: переменной, абстракцией или аппликацией.
Для **чистых** лямбда-выражений результат переписывания всегда будет лямбда-выражением.

1. (&lambda;f.&lambda;x.fx)&lambda;y.y+1

    Первое лямбда-выражение определяет функцию, аргумент *f* которой также является функцией, а тело *&lambda;x.fx*
    является другой функцией (которая принимает аргумент *x* и вызывает с ним *f*). Ниже приведены дерево с абстрактным
    синтаксисом и переписывание; возможно вы захотите попробовать нарисовать их сами.
    
    <pre>
        apply      =>   &lambda;        =>    &lambda;        &lambda;x.x+1
       /     \         / \            / \
      &lambda;       &lambda;       x  apply       x   +    
     / \     / \         /   \          / \
    f   &lambda;   y   +       &lambda;     x        x   1
       / \     / \     / \
      x  apply y  1   y   +
         /  \            / \
        f    x          y   1
    </pre>
    
    Обратите внимание, что результатом переписывания является функция. Также заметим, хотя в этом примере и используются
    2 узла "apply", только один из них имеет лямбда-узел, поэтому переписывание может быть начато только одним способом.

2. (&lambda;x.&lambda;y.x)(&lambda;z.z)

    В этом примере первая лямбда принимает один аргумент *x*, и возвращает функцию, которая игнорирует свой собственный 
    аргумент (*y*), просто возвращая *x*. В данном случае значение передаваемое как *x* является функцией.

    <pre>
               apply            &lambda;         &lambda;y.&lambda;z.z
              /     \          / \
             &lambda;       &lambda;    =>  y   &lambda;
            / \     / \          / \
           x   &lambda;   z   z        z   z
              / \
             y   x
    </pre>

----

## Тест для самопроверки #2

Нарисуйте дерево с абстрактным синтаксисом и выполните переписывание для лямбда-выражения:

> (&lambda;x.&lambda;y.xy)(&lambda;z.z)

[Ответ](#Ответ-2)

----

### Ответ 1

<pre>
        apply         =>    +     =>  +   =>  +  =>  6
       /     \             / \       / \     / \
      &lambda;       apply     apply 1     +   1   5   1
     / \       /  \      / \       / \
    x   +     &lambda;    3    &lambda;   3    3    2
       / \   / \       / \     
      x   1 y   +     y   +    
               / \       / \
	      y   2     y   2
</pre>

### Ответ 2

<pre>
     apply      =>       &lambda;     =>        &lambda;      &lambda;y.y
    /     \             / \             / \
   &lambda;       &lambda;           y   apply       y   y
  / \     / \             /     \
 x   &lambda;   z   z           &lambda;       y
    / \                 / \
   y  apply            z   z
     /     \
    x       y
</pre>
